<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Flipbook Viewer</title>
    <!-- Use Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        /* Basic styles for the page */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            background-color: #333; /* Dark background */
            overflow: hidden; /* Hide scrollbars */
        }

        /* Loading indicator */
        #loading {
            font-size: 1.5rem;
            color: white;
            text-align: center;
            padding: 20px;
        }

        /* Container for the flipbook and controls */
        #flipbook-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            visibility: hidden; /* Hide until ready */
        }

        /* * New viewport wrapper for zoom.
         * This allows us to have a scrollable area when zoomed in.
        */
        #flipbook-viewport {
            flex-grow: 1; /* Take up available space */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Will become 'auto' when zoomed */
            margin-bottom: 15px; /* Space between book and controls */
        }

        /* The flipbook itself */
        #flipbook {
            /* Dimensions are set by JavaScript based on PDF size */
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transform-origin: center center;
            transition: transform 0.3s ease; /* Animate zoom */
        }

        /* Styles for each page (canvas container) */
        #flipbook .page {
            background-color: white;
            overflow: hidden;
        }
        
        /* The canvas element where the PDF page is drawn */
        #flipbook .page canvas {
            width: 100%;
            height: 100%;
        }

        /* Turn.js adds this class to hard covers (first/last page) */
        #flipbook .hard {
            background-color: #f5f5f5; /* Slightly off-white for cover */
            border: 1px solid #ccc;
        }

        /* Navigation controls */
        #controls {
            /* margin-top: 20px; removed */
            padding-bottom: 15px; /* Replaced margin-top */
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-shrink: 0; /* Don't shrink the controls bar */
        }

        #controls button {
            background-color: #555;
            color: white;
            border: none;
            padding: 10px 18px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #controls button:hover {
            background-color: #777;
        }

        #controls button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }

        #page-num {
            color: white;
            font-size: 1rem;
            min-width: 80px;
            text-align: center;
            user-select: none; /* Prevent text selection */
        }

        /* Simple divider for controls */
        .control-divider {
            width: 1px;
            height: 25px;
            background-color: #666;
        }
    </style>
</head>
<body>

    <!-- Loading message shown at the start -->
    <div id="loading">
        <p>Loading PDF...</p>
        <p id="loading-progress"></p>
    </div>

    <!-- This container holds the flipbook and controls -->
    <!-- It's hidden by default and shown by JavaScript when ready -->
    <div id="flipbook-container">
        <!-- New Viewport Wrapper -->
        <div id="flipbook-viewport">
            <div id="flipbook">
                <!-- Pages will be dynamically added here by JavaScript -->
            </div>
        </div>
        
        <div id="controls">
            <!-- Page Navigation -->
            <button id="prev-page" disabled>&laquo; Prev</button>
            <span id="page-num"></span>
            <button id="next-page">Next &raquo;</button>
            
            <div class="control-divider"></div>

            <!-- Zoom Controls -->
            <button id="zoom-out" disabled>-</button>
            <span>Zoom</span>
            <button id="zoom-in">+</button>

            <div class="control-divider"></div>

            <!-- Fullscreen Control -->
            <button id="fullscreen-btn">Fullscreen</button>
        </div>
    </div>

    <!-- 
      JavaScript Libraries
      1. jQuery: Required by Turn.js
      2. Turn.js: The flipbook animation library
      3. PDF.js: The PDF rendering library
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/turn.js/3/turn.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

    <script>
        // --- Configuration ---
        const PDF_URL = '20th-aavc-program.pdf';
        const MAX_ZOOM = 3;
        const MIN_ZOOM = 1;
        const ZOOM_STEP = 0.25;
        // --- End Configuration ---


        // Set workerSrc for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Get DOM elements
        const loadingEl = document.getElementById('loading');
        const loadingProgressEl = document.getElementById('loading-progress');
        const containerEl = document.getElementById('flipbook-container');
        const flipbookViewport = document.getElementById('flipbook-viewport');
        const flipbookEl = document.getElementById('flipbook');
        
        // Page nav controls
        const prevBtn = document.getElementById('prev-page');
        const nextBtn = document.getElementById('next-page');
        const pageNumEl = document.getElementById('page-num');

        // Zoom controls
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        
        // Fullscreen control
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        let pdfDoc = null;
        let totalPages = 0;
        let bookWidth = 0;
        let bookHeight = 0;
        let zoomLevel = 1;

        /**
         * Asynchronously loads and renders the PDF document.
         */
        async function loadFlipbook(url) {
            try {
                // 1. Load the PDF document
                loadingProgressEl.innerText = '(Fetching file...)';
                const pdf = await pdfjsLib.getDocument({
                    url: url,
                    cache: "no-cache" 
                }).promise;
                pdfDoc = pdf;
                totalPages = pdf.numPages;

                // 2. Get the first page to determine aspect ratio
                const firstPage = await pdf.getPage(1);
                const viewport = firstPage.getViewport({ scale: 1 });
                const aspectRatio = viewport.height / viewport.width;

                // 3. Calculate responsive book dimensions
                // Use viewport dimensions to calculate max size
                // *** BUG WAS HERE ***
                // We were trying to measure flipbookViewport while its parent was
                // visibility: hidden, which returns 0 for width/height.
                // const viewportRect = flipbookViewport.getBoundingClientRect();
                // const maxWidth = viewportRect.width * 0.95;
                // const maxHeight = viewportRect.height * 0.95;
                
                // *** FIX ***
                // Revert to using the reliable window dimensions, like before.
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.9;
                
                bookWidth = Math.min(1200, maxWidth);
                bookHeight = (bookWidth / 2) * aspectRatio;

                if (bookHeight > maxHeight) {
                    bookHeight = maxHeight;
                    bookWidth = (bookHeight / aspectRatio) * 2;
                }

                const pageWidth = bookWidth / 2;
                const pageHeight = bookHeight;

                // Set flipbook element dimensions
                flipbookEl.style.width = `${bookWidth}px`;
                flipbookEl.style.height = `${bookHeight}px`;

                // 4. Render all pages into canvas elements
                const renderPromises = [];

                for (let i = 1; i <= totalPages; i++) {
                    const pageElement = document.createElement('div');
                    pageElement.classList.add('page');
                    
                    if (i === 1 || i === totalPages) {
                        pageElement.classList.add('hard');
                    }

                    const canvas = document.createElement('canvas');
                    pageElement.appendChild(canvas);
                    flipbookEl.appendChild(pageElement);

                    renderPromises.push(renderPage(pdf, i, canvas, pageWidth, pageHeight));
                }
                
                await Promise.all(renderPromises);

                // 5. All pages are rendered, initialize Turn.js
                $(flipbookEl).turn({
                    width: bookWidth,
                    height: bookHeight,
                    elevation: 50,
                    display: 'double',
                    autoCenter: true,
                    acceleration: true,
                    pages: totalPages,
                    gradients: true,
                    when: {
                        turned: function(event, page, view) {
                            updateControls(page, totalPages);
                        }
                    }
                });

                // 6. Show the flipbook and controls, hide loading
                loadingEl.style.display = 'none';
                containerEl.style.visibility = 'visible';
                updateControls(1, totalPages);

            } catch (error) {
                console.error('Error loading PDF:', error);
                loadingEl.innerHTML = '<p>Error loading PDF.</p>' +
                                      '<p style="font-size: 1rem; color: #ffcc80;">Could not find the file at the specified URL.</p>' +
                                      '<p style="font-size: 1rem;">Please check the `PDF_URL` variable in the code and make sure the file exists at that path.</p>';
            }
        }

        /**
         * Renders a single PDF page onto a canvas.
         */
        async function renderPage(pdf, pageNum, canvas, pageWidth, pageHeight) {
            try {
                loadingProgressEl.innerText = `(Rendering page ${pageNum} of ${totalPages}...)`;
                
                const page = await pdf.getPage(pageNum);
                
                const viewport = page.getViewport({ scale: 1 });
                const scale = Math.min(pageWidth / viewport.width, pageHeight / viewport.height);
                const scaledViewport = page.getViewport({ scale });

                const context = canvas.getContext('2d');
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;

                const renderContext = {
                    canvasContext: context,
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;

            } catch (error) {
                console.error(`Error rendering page ${pageNum}:`, error);
            }
        }

        /**
         * Updates the state of the navigation buttons and page number display.
         */
        function updateControls(page, total) {
            if (page === 1) {
                pageNumEl.innerText = `Cover (1 of ${total})`;
            } else if (page === total) {
                pageNumEl.innerText = `Back (${total} of ${total})`;
            } else if (page % 2 === 0) {
                pageNumEl.innerText = `Pages ${page} - ${page + 1} of ${total}`;
            } else {
                pageNumEl.innerText = `Pages ${page - 1} - ${page} of ${total}`;
            }
            
            prevBtn.disabled = (page <= 1);
            nextBtn.disabled = (page >= total);
        }

        /**
         * Applies the current zoom level to the flipbook.
         */
        function updateZoom() {
            flipbookEl.style.transform = `scale(${zoomLevel})`;
            // Allow scrolling if zoomed in
            flipbookViewport.style.overflow = zoomLevel > MIN_ZOOM ? 'auto' : 'hidden';
            
            // Disable page turning when zoomed in (to allow panning)
            $(flipbookEl).turn('disable', zoomLevel > MIN_ZOOM);

            // Update button states
            zoomOutBtn.disabled = zoomLevel <= MIN_ZOOM;
            zoomInBtn.disabled = zoomLevel >= MAX_ZOOM;
        }

        /**
         * Toggles the browser's fullscreen mode.
         */
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                fullscreenBtn.innerText = 'Exit Fullscreen';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    fullscreenBtn.innerText = 'Fullscreen';
                }
            }
        }

        // --- Event Listeners ---
        prevBtn.addEventListener('click', () => {
            $(flipbookEl).turn('previous');
        });

        nextBtn.addEventListener('click', () => {
            $(flipbookEl).turn('next');
        });

        window.addEventListener('keydown', (e) => {
            if (zoomLevel === MIN_ZOOM) { // Only allow keyboard nav if not zoomed
                if (e.key === 'ArrowLeft') {
                    $(flipbookEl).turn('previous');
                } else if (e.key === 'ArrowRight') {
                    $(flipbookEl).turn('next');
                }
            }
        });

        // Zoom Listeners
        zoomInBtn.addEventListener('click', () => {
            zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
            updateZoom();
        });

        zoomOutBtn.addEventListener('click', () => {
            zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
            updateZoom();
        });

        // Fullscreen Listeners
        fullscreenBtn.addEventListener('click', toggleFullScreen);
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.innerText = 'Fullscreen';
            }
        });

        /**
         * Robustly checks if turn.js is loaded and ready before starting.
         */
        function initializeApp() {
            if ($.fn.turn) {
                // turn.js is loaded and attached to jQuery
                console.log('turn.js loaded. Initializing flipbook...');
                loadFlipbook(PDF_URL); // Start by trying to load the user's provided PDF
            } else {
                // turn.js is not ready yet, check again in 100ms
                console.log('Waiting for turn.js to load...');
                setTimeout(initializeApp, 100);
            }
        }

        // Start the initialization check once the window is fully loaded.
        window.addEventListener('load', initializeApp);

    </script>
</body>
</html>


